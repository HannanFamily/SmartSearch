Attribute VB_Name = "DataTableUpdater"
Option Explicit

' Applies cleaned Equipment Descriptions (and optional Object Type suggestions)
' to the 'DataTable' on the 'Equipment Data' sheet.
' It looks for the latest files generated by the Python cleaner:
'   - CLEANED: Data_Cleanup/output/Equipment_Data_CLEANED_*.csv (complete rows; preferred for descriptions)
'   - Suggestions: Data_Cleanup/output/Equipment_Data_Cleanup_Suggestions_*.csv (Object Type suggestions)
'
' How it works
' - Finds the latest CLEANED CSV and builds a dict: SAP ID -> Equipment Description
' - Finds the latest Suggestions CSV and builds a dict: SAP ID -> Object Type (Suggested)
' - Iterates DataTable rows and updates in-place when values differ
' - Writes a small log sheet with counts and timestamp
'
Private Const OUTPUT_SUBFOLDER As String = "Data_Cleanup" & Application.PathSeparator & "output"
Private Const CLEANED_PREFIX As String = "Equipment_Data_CLEANED_"
Private Const SUGG_PREFIX As String = "Equipment_Data_Cleanup_Suggestions_"

Public Sub RUN_ApplyCleanedData()
    On Error GoTo EH
    ApplyCleanedDataToDataTable
    Exit Sub
EH:
    MsgBox "Error in RUN_ApplyCleanedData: " & Err.Number & ": " & Err.Description, vbExclamation
End Sub

Public Sub ApplyCleanedDataToDataTable()
    On Error GoTo EH

    Dim cleanedPath As String, suggPath As String
    cleanedPath = FindLatestInOutput(CLEANED_PREFIX)
    suggPath = FindLatestInOutput(SUGG_PREFIX)

    If Len(cleanedPath) = 0 Then
        cleanedPath = PromptForFile("Select CLEANED CSV", "CSV Files (*.csv),*.csv")
        If Len(cleanedPath) = 0 Then
            MsgBox "No CLEANED CSV selected. Aborting.", vbExclamation
            Exit Sub
        End If
    End If

    Dim dictDesc As Object: Set dictDesc = CreateObject("Scripting.Dictionary")
    Dim descCount As Long
    descCount = BuildDict_FromCleaned(cleanedPath, dictDesc)

    Dim dictObjType As Object: Set dictObjType = CreateObject("Scripting.Dictionary")
    Dim objTypeCount As Long
    If Len(suggPath) > 0 Then
        objTypeCount = BuildDict_FromSuggestions(suggPath, dictObjType)
    End If

    Dim dataLo As ListObject: Set dataLo = lo(DATA_TABLE_NAME)
    If dataLo Is Nothing Then
        MsgBox "Table '" & DATA_TABLE_NAME & "' not found.", vbExclamation
        Exit Sub
    End If
    If dataLo.DataBodyRange Is Nothing Then
        MsgBox "Table '" & DATA_TABLE_NAME & "' has no data.", vbInformation
        Exit Sub
    End If

    Dim idCol As Long, descCol As Long, typeCol As Long
    idCol = HeaderIndexByText(dataLo, "SAP Equipment ID")
    If idCol = 0 Then idCol = HeaderIndexByText(dataLo, "Equipment Number")
    descCol = HeaderIndexByText(dataLo, "Equipment Description")
    typeCol = HeaderIndexByText(dataLo, "Object Type")
    If idCol = 0 Or descCol = 0 Then
        MsgBox "Required columns not found in DataTable.", vbExclamation
        Exit Sub
    End If

    Dim r As Long, updatedDesc As Long, updatedType As Long
    Dim rid As String, curDesc As String, curType As String
    Dim newDesc As String, newType As String

    Application.ScreenUpdating = False
    For r = 1 To dataLo.DataBodyRange.Rows.Count
        rid = Trim$(CStr(dataLo.DataBodyRange.Cells(r, idCol).Value))
        If Len(rid) > 0 Then
            If dictDesc.Exists(rid) Then
                newDesc = dictDesc(rid)
                curDesc = CStr(dataLo.DataBodyRange.Cells(r, descCol).Value)
                If StrComp(Trim$(curDesc), Trim$(newDesc), vbTextCompare) <> 0 Then
                    dataLo.DataBodyRange.Cells(r, descCol).Value = newDesc
                    updatedDesc = updatedDesc + 1
                End If
            End If
            If typeCol > 0 And dictObjType.Exists(rid) Then
                newType = dictObjType(rid)
                curType = CStr(dataLo.DataBodyRange.Cells(r, typeCol).Value)
                If Len(newType) > 0 And StrComp(Trim$(curType), Trim$(newType), vbTextCompare) <> 0 Then
                    dataLo.DataBodyRange.Cells(r, typeCol).Value = newType
                    updatedType = updatedType + 1
                End If
            End If
        End If
    Next r
    Application.ScreenUpdating = True

    WriteApplyLog cleanedPath, suggPath, descCount, objTypeCount, updatedDesc, updatedType
    MsgBox "Applied cleaned data. Descriptions updated: " & updatedDesc & _
           ", Object Types updated: " & updatedType, vbInformation
    Exit Sub
EH:
    Application.ScreenUpdating = True
    MsgBox "Error in ApplyCleanedDataToDataTable: " & Err.Number & ": " & Err.Description, vbExclamation
End Sub

Private Function FindLatestInOutput(prefix As String) As String
    Dim basePath As String
    basePath = ResolveOutputFolder()
    If Len(basePath) = 0 Then Exit Function
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FolderExists(basePath) Then Exit Function
    Dim f As Object, latestFile As String, latestDate As Date
    latestFile = "": latestDate = #1/1/1900#
    For Each f In fso.GetFolder(basePath).Files
        If InStr(1, f.Name, prefix, vbTextCompare) = 1 Then
            If f.DateLastModified > latestDate Then
                latestDate = f.DateLastModified
                latestFile = f.Path
            End If
        End If
    Next f
    FindLatestInOutput = latestFile
End Function

Private Function ResolveOutputFolder() As String
    Dim wbPath As String: wbPath = ThisWorkbook.Path
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    ' Try sibling folder: ../Data_Cleanup/output
    Dim candidate As String
    candidate = fso.BuildPath(fso.GetParentFolderName(wbPath), OUTPUT_SUBFOLDER)
    If fso.FolderExists(candidate) Then
        ResolveOutputFolder = candidate
        Exit Function
    End If
    ' Try workbook folder/Data_Cleanup/output
    candidate = fso.BuildPath(wbPath, OUTPUT_SUBFOLDER)
    If fso.FolderExists(candidate) Then
        ResolveOutputFolder = candidate
        Exit Function
    End If
    ResolveOutputFolder = ""
End Function

Private Function PromptForFile(promptTitle As String, filterSpec As String) As String
    On Error Resume Next
    Dim fd As FileDialog
    Set fd = Application.FileDialog(msoFileDialogFilePicker)
    With fd
        .AllowMultiSelect = False
        .Title = promptTitle
        .Filters.Clear
        .Filters.Add "Allowed", Split(filterSpec, ",")(1)
        If .Show = -1 Then
            PromptForFile = .SelectedItems(1)
        Else
            PromptForFile = ""
        End If
    End With
End Function

Private Function BuildDict_FromCleaned(csvPath As String, dictOut As Object) As Long
    Dim ts As Object, fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FileExists(csvPath) Then Exit Function
    Set ts = fso.OpenTextFile(csvPath, 1, False, -1) ' -1 Unicode
    Dim headers As Variant, hIdx As Object: Set hIdx = CreateObject("Scripting.Dictionary")
    If Not ts.AtEndOfStream Then headers = ParseCsvLine(ts.ReadLine)
    Dim i As Long
    For i = LBound(headers) To UBound(headers)
        hIdx(LCase$(CStr(headers(i)))) = i
    Next i
    Dim idField As String, descField As String
    idField = "sap equipment id"
    If Not hIdx.Exists(idField) Then idField = "equipment number"
    descField = "equipment description"
    If Not hIdx.Exists(idField) Or Not hIdx.Exists(descField) Then Exit Function
    Dim cnt As Long
    Do While Not ts.AtEndOfStream
        Dim ln As String: ln = ts.ReadLine
        Dim arr As Variant: arr = ParseCsvLine(ln)
        Dim rid As String: rid = SafeIndex(arr, hIdx(idField))
        Dim descVal As String: descVal = SafeIndex(arr, hIdx(descField))
        If Len(Trim$(rid)) > 0 Then
            dictOut(Trim$(rid)) = descVal
            cnt = cnt + 1
        End If
    Loop
    ts.Close
    BuildDict_FromCleaned = cnt
End Function

Private Function BuildDict_FromSuggestions(csvPath As String, dictOut As Object) As Long
    Dim ts As Object, fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FileExists(csvPath) Then Exit Function
    Set ts = fso.OpenTextFile(csvPath, 1, False, -1)
    Dim headers As Variant, hIdx As Object: Set hIdx = CreateObject("Scripting.Dictionary")
    If Not ts.AtEndOfStream Then headers = ParseCsvLine(ts.ReadLine)
    Dim i As Long
    For i = LBound(headers) To UBound(headers)
        hIdx(LCase$(CStr(headers(i)))) = i
    Next i
    Dim idField As String, typeField As String
    idField = "equipment number" ' our exporter puts SAP ID here
    typeField = "object type (suggested)"
    If Not hIdx.Exists(idField) Or Not hIdx.Exists(typeField) Then Exit Function
    Dim cnt As Long
    Do While Not ts.AtEndOfStream
        Dim ln As String: ln = ts.ReadLine
        Dim arr As Variant: arr = ParseCsvLine(ln)
        Dim rid As String: rid = SafeIndex(arr, hIdx(idField))
        Dim typeVal As String: typeVal = SafeIndex(arr, hIdx(typeField))
        If Len(Trim$(rid)) > 0 And Len(Trim$(typeVal)) > 0 Then
            dictOut(Trim$(rid)) = typeVal
            cnt = cnt + 1
        End If
    Loop
    ts.Close
    BuildDict_FromSuggestions = cnt
End Function

Private Function ParseCsvLine(ByVal line As String) As Variant
    Dim res() As String
    Dim i As Long, ch As String * 1, inQuotes As Boolean, cur As String
    ReDim res(0 To 0)
    For i = 1 To Len(line)
        ch = Mid$(line, i, 1)
        If ch = '"' Then
            If inQuotes And i < Len(line) And Mid$(line, i + 1, 1) = '"' Then
                cur = cur & '"'
                i = i + 1
            Else
                inQuotes = Not inQuotes
            End If
        ElseIf ch = "," And Not inQuotes Then
            res(UBound(res)) = cur
            cur = vbNullString
            ReDim Preserve res(0 To UBound(res) + 1)
        Else
            cur = cur & ch
        End If
    Next i
    res(UBound(res)) = cur
    ParseCsvLine = res
End Function

Private Function SafeIndex(arr As Variant, idx As Long) As String
    On Error Resume Next
    If IsArray(arr) Then
        If idx >= LBound(arr) And idx <= UBound(arr) Then
            SafeIndex = CStr(arr(idx))
        Else
            SafeIndex = vbNullString
        End If
    Else
        SafeIndex = vbNullString
    End If
End Function

Private Sub WriteApplyLog(cleanedPath As String, suggPath As String, _
                          inDesc As Long, inType As Long, outDesc As Long, outType As Long)
    On Error Resume Next
    Dim ws As Worksheet
    Set ws = SheetByName("DataCleanup_Apply_Log")
    If ws Is Nothing Then
        Set ws = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count))
        ws.Name = "DataCleanup_Apply_Log"
    End If
    Dim r As Long: r = ws.Cells(ws.Rows.Count, 1).End(xlUp).Row + 1
    If r = 2 Then
        ws.Cells(1, 1).Resize(1, 7).Value = Array("Timestamp", "Cleaned CSV", "Suggestions CSV", "Cleaned Rows", "Suggested Types", "Descriptions Updated", "Types Updated")
    End If
    ws.Cells(r, 1).Value = Now
    ws.Cells(r, 2).Value = cleanedPath
    ws.Cells(r, 3).Value = suggPath
    ws.Cells(r, 4).Value = inDesc
    ws.Cells(r, 5).Value = inType
    ws.Cells(r, 6).Value = outDesc
    ws.Cells(r, 7).Value = outType
End Sub
